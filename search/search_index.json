{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"String Grouper","text":"Click to see image <p> The image displayed above is a visualization of the graph-structure of one of the groups of strings found by <code>string_grouper</code>.  Each circle (node) represents a string, and each connecting arc (edge) represents a match between a pair of strings with a similarity score above a given threshold score (here <code>0.8</code>).  </p> <p>The centroid of the group, as determined by <code>string_grouper</code> (see tutorials/group_representatives.md for an explanation), is the largest node, also with the most edges originating from it.  A thick line in the image denotes a strong similarity between the nodes at its ends, while a faint thin line denotes weak similarity.</p> <p>The power of <code>string_grouper</code> is discernible from this image: in large datasets, <code>string_grouper</code> is often able to resolve indirect associations between strings even when, say, due to memory-resource-limitations, direct matches between those strings cannot be computed using conventional methods with a lower threshold similarity score.    </p> <p> \u2014\u2014\u2014</p> <p>This image was designed using the graph-visualization software Gephi 0.9.2 with data generated by <code>string_grouper</code> operating on the sec__edgar_company_info.csv sample data file.</p> <p><code>string_grouper</code> is a library that makes finding groups of similar strings within a single, or multiple, lists of strings easy \u2014 and fast. <code>string_grouper</code> uses tf-idf to calculate cosine similarities within a single list or between two lists of strings. The full process is described in the blog Super Fast String Matching in Python.</p>"},{"location":"#install","title":"Install","text":"<pre><code>pip install git+https://github.com/GuillaumePressiat/string_grouper#from_0.6_to_0.7\n</code></pre> <p>or see the releases here</p>"},{"location":"#speed","title":"Speed","text":"<pre><code>%%time\nimport polars as pl\nfrom string_grouper import match_strings\n\n# Import data\ncompany_names = '.data/sec_edgar_company_info.csv'\ncompanies = pl.read_csv(company_names)\ncompanies.shape\ncompanies = companies.to_pandas()\n\n# Create all matches:\nmatches = pl.from_pandas(match_strings(companies['Company Name'], \n                                       max_n_matches = 4,\n                                       min_similarity = 0.8,\n                                       n_blocks = (1, 150), \n                                       number_of_processes = 9)\n)\n</code></pre> <pre><code># companies.shape : \n# (663000, 3)\n# %%time : \n# CPU times: user 8min 21s, sys: 2.07 s, total: 8min 23s\n# Wall time: 1min 20s\n</code></pre>"},{"location":"#first-usage","title":"First usage","text":"<pre><code>import pandas as pd\nfrom string_grouper import match_strings\n\n#https://github.com/ngshya/pfsm/blob/master/data/sec_edgar_company_info.csv\ncompany_names = './data/sec_edgar_company_info.csv'\n# We only look at the first 50k as an example:\ncompanies = pd.read_csv(company_names)[0:50000]\n# Create all matches:\nmatches = match_strings(companies['Company Name'])\n# Look at only the non-exact matches:\nmatches[matches['left_Company Name'] != matches['right_Company Name']].head()\n</code></pre> <p>As shown above, the library may be used together with <code>pandas</code>, and contains four high level functions (<code>match_strings</code>, <code>match_most_similar</code>, <code>group_similar_strings</code>, and <code>compute_pairwise_similarities</code>) that can be used directly, and one class (<code>StringGrouper</code>) that allows for a more interactive approach. </p> <p>The permitted calling patterns of the four functions, and their return types, are:</p> Function Parameters <code>pandas</code> Return Type <code>match_strings</code> <code>(master, **kwargs)</code> <code>DataFrame</code> <code>match_strings</code> <code>(master, duplicates, **kwargs)</code> <code>DataFrame</code> <code>match_strings</code> <code>(master, master_id=id_series, **kwargs)</code> <code>DataFrame</code> <code>match_strings</code> <code>(master, duplicates, master_id, duplicates_id, **kwargs)</code> <code>DataFrame</code>"},{"location":"#with-polars","title":"With polars","text":"<p>For the moment polars is not yet supported natively.</p> <p>But you can juggle easily one with the other:</p> <pre><code>import polars as pl\nfrom string_grouper import match_strings\n\ncompany_names = 'https://raw.githubusercontent.com/ngshya/pfsm/refs/heads/master/data/sec_edgar_company_info.csv'\n# We only look at the first 50k as an example:\ncompanies = pl.read_csv(company_names).slice(0,50000).to_pandas()\n# Create all matches:\nmatches = pl.from_pandas(match_strings(companies['Company Name']))\n# Look at only the non-exact matches:\nmatches.filter(pl.col('left_Company Name') != pl.col('right_Company Name')).head()\n</code></pre> <p>In the rest of this document the names, <code>Series</code> and <code>DataFrame</code>, refer to the familiar <code>pandas</code> object types.</p>"},{"location":"#generic-parameters","title":"Generic parameters","text":"Name Description <code>master</code> A <code>Series</code> of strings to be matched with themselves (or with those in <code>duplicates</code>). <code>duplicates</code> A <code>Series</code> of strings to be matched with those of <code>master</code>. <code>master_id</code> (or <code>id_series</code>) A <code>Series</code> of IDs corresponding to the strings in <code>master</code>. <code>duplicates_id</code> A <code>Series</code> of IDs corresponding to the strings in <code>duplicates</code>. <code>strings_to_group</code> A <code>Series</code> of strings to be grouped. <code>strings_id</code> A <code>Series</code> of IDs corresponding to the strings in <code>strings_to_group</code>. <code>string_series_1(_2)</code> A <code>Series</code> of strings each of which is to be compared with its corresponding string in <code>string_series_2(_1)</code>. <code>**kwargs</code> Keyword arguments (see below). <p>New in version 0.6.0: each of the high-level functions listed above also has a <code>StringGrouper</code> method counterpart of the same name and parameters.  Calling such a method of any instance of <code>StringGrouper</code> will not rebuild the instance's underlying corpus to make string-comparisons but rather use it to perform the string-comparisons.  The input Series to the method (<code>master</code>, <code>duplicates</code>, and so on) will thus be encoded, or transformed, into tf-idf matrices, using this corpus.  For example:</p> <p><pre><code># Build a corpus using strings in the pandas Series master:\nsg = StringGrouper(master)\n# The following method-calls will compare strings first in\n# pandas Series new_master_1 and next in new_master_2\n# using the corpus already built above without rebuilding or\n# changing it in any way:\nmatches1 = sg.match_strings(new_master_1)\nmatches2 = sg.match_strings(new_master_2)\n</code></pre> New in version 0.7.0: dependency sparse_dot_topn from ing-bank version 1.1 is used</p>"},{"location":"examples/","title":"Examples","text":"<p>In this section we will cover a few use cases for which string_grouper may be used. We will use the same data set of company names as used in: Super Fast String Matching in Python.</p>"},{"location":"examples/#find-all-matches-within-a-single-data-set","title":"Find all matches within a single data set","text":"<pre><code>import pandas as pd\nimport numpy as np\nfrom string_grouper import match_strings, match_most_similar, \\\n    group_similar_strings, compute_pairwise_similarities, \\\n    StringGrouper\n</code></pre> <pre><code>company_names = './data/sec_edgar_company_info.csv'\n# We only look at the first 50k as an example:\ncompanies = pd.read_csv(company_names)[0:50000]\n# Create all matches:\nmatches = match_strings(companies['Company Name'])\n# Look at only the non-exact matches:\nmatches[matches['left_Company Name'] != matches['right_Company Name']].head()\n</code></pre> left_index left_Company Name similarity right_Company Name right_index 15 14 0210, LLC 0.870291 90210 LLC 4211 167 165 1 800 MUTUALS ADVISOR SERIES 0.931615 1 800 MUTUALS ADVISORS SERIES 166 168 166 1 800 MUTUALS ADVISORS SERIES 0.931615 1 800 MUTUALS ADVISOR SERIES 165 172 168 1 800 RADIATOR FRANCHISE INC 1.000000 1-800-RADIATOR FRANCHISE INC. 201 178 173 1 FINANCIAL MARKETPLACE SECURITIES LLC        ... 0.949364 1 FINANCIAL MARKETPLACE SECURITIES, LLC 174"},{"location":"examples/#find-all-matches-in-between-two-data-sets","title":"Find all matches in between two data sets.","text":"<p>The <code>match_strings</code> function finds similar items between two data sets as well. This can be seen as an inner join between two data sets:</p> <pre><code># Create a small set of artificial company names:\nduplicates = pd.Series(['S MEDIA GROUP', '012 SMILE.COMMUNICATIONS', 'foo bar', 'B4UTRADE COM CORP'])\n# Create all matches:\nmatches = match_strings(companies['Company Name'], duplicates)\nmatches\n</code></pre> left_index left_Company Name similarity right_side right_index 0 12 012 SMILE.COMMUNICATIONS LTD 0.944092 012 SMILE.COMMUNICATIONS 1 1 49777 B.A.S. MEDIA GROUP 0.854383 S MEDIA GROUP 0 2 49855 B4UTRADE COM CORP 1.000000 B4UTRADE COM CORP 3 3 49856 B4UTRADE COM INC 0.810217 B4UTRADE COM CORP 3 4 49857 B4UTRADE CORP 0.878276 B4UTRADE COM CORP 3 <p>Out of the four company names in <code>duplicates</code>, three companies are found in the original company data set. One company is found three times.</p>"},{"location":"examples/#finding-duplicates-from-a-database-extract-to-dataframe-where-ids-for-rows-are-supplied","title":"Finding duplicates from a (database extract to) DataFrame where IDs for rows are supplied.","text":"<p>A very common scenario is the case where duplicate records for an entity have been entered into a database. That is, there are two or more records where a name field has slightly different spelling. For example, \"A.B. Corporation\" and \"AB Corporation\". Using the optional 'ID' parameter in the <code>match_strings</code> function duplicates can be found easily. A tutorial that steps though the process with an example data set is available.</p>"},{"location":"examples/#for-a-second-data-set-find-only-the-most-similar-match","title":"For a second data set, find only the most similar match","text":"<p>In the example above, it's possible that multiple matches are found for a single string. Sometimes we just want a string to match with a single most similar string. If there are no similar strings found, the original string should be returned:</p> <pre><code># Create a small set of artificial company names:\nnew_companies = pd.Series(['S MEDIA GROUP', '012 SMILE.COMMUNICATIONS', 'foo bar', 'B4UTRADE COM CORP'],\\\n                          name='New Company')\n# Create all matches:\nmatches = match_most_similar(companies['Company Name'], new_companies, ignore_index=True)\n# Display the results:\npd.concat([new_companies, matches], axis=1)\n</code></pre> New Company most_similar_Company Name 0 S MEDIA GROUP B.A.S. MEDIA GROUP 1 012 SMILE.COMMUNICATIONS 012 SMILE.COMMUNICATIONS LTD 2 foo bar foo bar 3 B4UTRADE COM CORP B4UTRADE COM CORP"},{"location":"examples/#deduplicate-a-single-data-set-and-show-items-with-most-duplicates","title":"Deduplicate a single data set and show items with most duplicates","text":"<p>The <code>group_similar_strings</code> function groups strings that are similar using a single linkage clustering algorithm. That is, if item A and item B are similar; and item B and item C are similar; but the similarity between A and C is below the threshold; then all three items are grouped together. </p> <pre><code># Add the grouped strings:\ncompanies['deduplicated_name'] = group_similar_strings(companies['Company Name'],\n                                                       ignore_index=True)\n# Show items with most duplicates:\ncompanies.groupby('deduplicated_name')['Line Number'].count().sort_values(ascending=False).head(10)\n</code></pre> <pre><code>deduplicated_name\nADVISORS DISCIPLINED TRUST                                      1824\nAGL LIFE ASSURANCE CO SEPARATE ACCOUNT                           183\nANGELLIST-ART-FUND, A SERIES OF ANGELLIST-FG-FUNDS, LLC          116\nAMERICREDIT AUTOMOBILE RECEIVABLES TRUST 2001-1                   87\nACE SECURITIES CORP. HOME EQUITY LOAN TRUST, SERIES 2006-HE2      57\nASSET-BACKED PASS-THROUGH CERTIFICATES SERIES 2004-W1             40\nALLSTATE LIFE GLOBAL FUNDING TRUST 2005-3                         39\nALLY AUTO RECEIVABLES TRUST 2014-1                                33\nANDERSON ROBERT E /                                               28\nADVENT INTERNATIONAL GPE VIII LIMITED PARTNERSHIP                 28\nName: Line Number, dtype: int64\n</code></pre> <p>The <code>group_similar_strings</code> function also works with IDs: imagine a <code>DataFrame</code> (<code>customers_df</code>) with the following content: <pre><code># Create a small set of artificial customer names:\ncustomers_df = pd.DataFrame(\n   [\n      ('BB016741P', 'Mega Enterprises Corporation'),\n      ('CC082744L', 'Hyper Startup Incorporated'),\n      ('AA098762D', 'Hyper Startup Inc.'),\n      ('BB099931J', 'Hyper-Startup Inc.'),\n      ('HH072982K', 'Hyper Hyper Inc.')\n   ],\n   columns=('Customer ID', 'Customer Name')\n).set_index('Customer ID')\n# Display the data:\ncustomers_df\n</code></pre></p> Customer Name Customer ID BB016741P Mega Enterprises Corporation CC082744L Hyper Startup Incorporated AA098762D Hyper Startup Inc. BB099931J Hyper-Startup Inc. HH072982K Hyper Hyper Inc. <p>The output of <code>group_similar_strings</code> can be directly used as a mapping table: <pre><code># Group customers with similar names:\ncustomers_df[[\"group-id\", \"name_deduped\"]]  = \\\n    group_similar_strings(customers_df[\"Customer Name\"])\n# Display the mapping table:\ncustomers_df\n</code></pre></p> Customer Name group-id name_deduped Customer ID BB016741P Mega Enterprises Corporation BB016741P Mega Enterprises Corporation CC082744L Hyper Startup Incorporated CC082744L Hyper Startup Incorporated AA098762D Hyper Startup Inc. AA098762D Hyper Startup Inc. BB099931J Hyper-Startup Inc. AA098762D Hyper Startup Inc. HH072982K Hyper Hyper Inc. HH072982K Hyper Hyper Inc. <p>Note that here <code>customers_df</code> initially had only one column \"Customer Name\" (before the <code>group_similar_strings</code> function call); and it acquired two more columns \"group-id\" (the index-column) and \"name_deduped\" after the call through a \"setting with enlargement\" (a <code>pandas</code> feature).</p>"},{"location":"examples/#simply-compute-the-cosine-similarities-of-pairs-of-strings","title":"Simply compute the cosine similarities of pairs of strings","text":"<p>Sometimes we have pairs of strings that have already been matched but whose similarity scores need to be computed.  For this purpose we provide the function <code>compute_pairwise_similarities</code>:</p> <pre><code># Create a small DataFrame of pairs of strings:\npair_s = pd.DataFrame(\n    [\n        ('Mega Enterprises Corporation', 'Mega Enterprises Corporation'),\n        ('Hyper Startup Inc.', 'Hyper Startup Incorporated'),\n        ('Hyper Startup Inc.', 'Hyper Startup Inc.'),\n        ('Hyper Startup Inc.', 'Hyper-Startup Inc.'),\n        ('Hyper Hyper Inc.', 'Hyper Hyper Inc.'),\n        ('Mega Enterprises Corporation', 'Mega Enterprises Corp.')\n   ],\n   columns=('left', 'right')\n)\n# Display the data:\npair_s\n</code></pre> left right 0 Mega Enterprises Corporation Mega Enterprises Corporation 1 Hyper Startup Inc. Hyper Startup Incorporated 2 Hyper Startup Inc. Hyper Startup Inc. 3 Hyper Startup Inc. Hyper-Startup Inc. 4 Hyper Hyper Inc. Hyper Hyper Inc. 5 Mega Enterprises Corporation Mega Enterprises Corp. <pre><code># Compute their cosine similarities and display them:\npair_s['similarity'] = compute_pairwise_similarities(pair_s['left'], pair_s['right'])\npair_s\n</code></pre> left right similarity 0 Mega Enterprises Corporation Mega Enterprises Corporation 1.000000 1 Hyper Startup Inc. Hyper Startup Incorporated 0.633620 2 Hyper Startup Inc. Hyper Startup Inc. 1.000000 3 Hyper Startup Inc. Hyper-Startup Inc. 1.000000 4 Hyper Hyper Inc. Hyper Hyper Inc. 1.000000 5 Mega Enterprises Corporation Mega Enterprises Corp. 0.826463"},{"location":"performance/","title":"Performance","text":""},{"location":"performance/#performance","title":"Performance","text":"<p>Semilogx plots of run-times of <code>match_strings()</code> vs the number of blocks (<code>n_blocks[1]</code>) into which the right matrix-operand of the dataset (663 000 strings from sec__edgar_company_info.csv) was split before performing the string comparison.  As shown in the legend, each plot corresponds to the number <code>n_blocks[0]</code> of blocks into which the left matrix-operand was split. </p> <p>String comparison, as implemented by <code>string_grouper</code>, is essentially matrix  multiplication.  A pandas Series of strings is converted (tokenized) into a  matrix.  Then that matrix is multiplied by itself (or another) transposed.  </p> <p>Here is an illustration of multiplication of two matrices D and M<sup>T</sup>: </p> <p>It turns out that when the matrix (or Series) is very large, the computer  proceeds quite slowly with the multiplication (apparently due to the RAM being  too full).  Some computers give up with an <code>OverflowError</code>.</p> <p>To circumvent this issue, <code>string_grouper</code> now allows the division of the Series  into smaller chunks (or blocks) and multiplies the chunks one pair at a time  instead to get the same result:</p> <p></p> <p>But surprise ... the run-time of the process is sometimes drastically reduced  as a result.  For example, the speed-up of the following call is about 500%  (here, the Series is divided into 200 blocks on the right operand, that is,  1 block on the left \u00d7 200 on the right) compared to the same call with no splitting [<code>n_blocks=(1, 1)</code>, the default, which is what previous versions  (0.5.0 and earlier) of <code>string_grouper</code> did]:</p> <pre><code># A DataFrame of 668 000 records:\ncompanies = pd.read_csv('data/sec__edgar_company_info.csv')\n\n# The following call is more than 6 times faster than earlier versions of \n# match_strings() (that is, when n_blocks=(1, 1))!\nmatch_strings(companies['Company Name')], n_blocks=(1, 200))\n</code></pre> <p>Further exploration of the block number space (see plot above) has revealed that for any fixed  number of right blocks, the run-time gets longer the larger the number of left  blocks specified.  For this reason, it is recommended not to split the left matrix.</p> <p></p> <p>In general,</p> <p> total runtime = <code>n_blocks[0]</code> \u00d7 <code>n_blocks[1]</code> \u00d7 mean runtime per block-pair</p> <p>\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 = Left Operand Size \u00d7 Right Operand Size \u00d7 </p> <p> mean runtime per block-pair / (Left Block Size \u00d7 Right Block Size)</p> <p>So for given left and right operands, minimizing the total runtime is the same as minimizing the</p> <p> runtime per string-pair comparison \u225d  mean runtime per block-pair / (Left Block Size \u00d7 Right Block Size)</p> <p>Below is a log-log-log contour plot of the runtime per string-pair comparison scaled by its value at Left Block Size = Right Block Size = 5000.  Here, Block Size is the number of strings in that block, and mean runtime per block-pair is the time taken for the following call to run: <pre><code># note the parameter order!\nmatch_strings(right_Series, left_Series, n_blocks=(1, 1))\n</code></pre> where <code>left_Series</code> and <code>right_Series</code>, corresponding to Left Block and Right Block respectively, are random subsets of the Series <code>companies['Company Name')]</code> from the sec__edgar_company_info.csv sample data file.</p> <p> </p> <p>It can be seen that when <code>right_Series</code> is roughly the size of 80\u00a0000 (denoted by the  white dashed line in the contour plot above), the runtime per string-pair comparison is at  its lowest for any fixed <code>left_Series</code> size.  Above Right Block Size = 80\u00a0000, the  matrix-multiplication routine begins to feel the limits of the computer's  available memory space and thus its performance deteriorates, as evidenced by the increase  in runtime per string-pair comparison there (above the white dashed line).  This knowledge  could serve as a guide for estimating the optimum block numbers \u2014 namely those that divide the Series into blocks of size roughly equal to  80\u00a0000 for the right operand (or <code>right_Series</code>).</p> <p>So what are the optimum block number values for any given Series? That is  anyone's guess, and may likely depend on the data itself.  Furthermore, as hinted above,  the answer may vary from computer to computer.  </p> <p>We however encourage the user to make judicious use of the <code>n_blocks</code>  parameter to boost performance of <code>string_grouper</code> whenever possible.</p>"},{"location":"references/","title":"References","text":"<p>All functions are built using a class <code>StringGrouper</code>. This class can be used through pre-defined functions, for example the four high level functions above, as well as using a more interactive approach where matches can be added or removed if needed by calling the <code>StringGrouper</code> class directly.</p>"},{"location":"references/compute_pairwise_similarities/","title":"compute_pairwise_similarities","text":""},{"location":"references/compute_pairwise_similarities/#arguments","title":"Arguments","text":"<pre><code>compute_pairwise_similarities(string_series_1: pd.Series,\n                              string_series_2: pd.Series,\n                              **kwargs) -&gt; pd.Series\n</code></pre>"},{"location":"references/compute_pairwise_similarities/#result","title":"Result","text":"<p>Returns a <code>Series</code> of cosine similarity scores the same length and index as <code>string_series_1</code>.  Each score is the cosine similarity between the pair of strings in the same position (row) in the two input <code>Series</code>, <code>string_series_1</code> and <code>string_series_2</code>, as the position of the score in the output <code>Series</code>.  This can be seen as an element-wise comparison between the two input <code>Series</code>.</p>"},{"location":"references/group_similar_strings/","title":"group_similar_strings","text":""},{"location":"references/group_similar_strings/#arguments","title":"Arguments","text":"<pre><code>## Arguments\n\ngroup_similar_strings(strings_to_group: pd.Series,\n                      string_ids: Optional[pd.Series],\n                      **kwargs) -&gt; Union[pd.DataFrame, pd.Series]\n</code></pre>"},{"location":"references/group_similar_strings/#result","title":"Result","text":"<p>Takes a single <code>Series</code> of strings (<code>strings_to_group</code>) and groups them by assigning to each string one string from <code>strings_to_group</code> chosen as the group-representative for each group of similar strings found. (See tutorials/group_representatives.md for details on how the the group-representatives are chosen.)   </p> <p>If <code>ignore_index=True</code>, the output is a <code>Series</code> (with the same name as <code>strings_to_group</code> prefixed by the string <code>'group_rep_'</code>) of the same length and index as <code>strings_to_group</code> containing the group-representative strings.  If <code>strings_to_group</code> has no name then the name of the returned <code>Series</code> is <code>'group_rep'</code>.  </p> <p>For example, an input Series with values: <code>['foooo', 'foooob', 'bar']</code> will return <code>['foooo', 'foooo', 'bar']</code>.  Here <code>'foooo'</code> and <code>'foooob'</code> are grouped together into group <code>'foooo'</code> because they are found to be similar.  Another example can be found below.</p> <p>If <code>ignore_index=False</code>, the output is a <code>DataFrame</code> containing the above output <code>Series</code> as one of its columns with the same name.  The remaining column(s) correspond to the index (or index-levels) of <code>strings_to_group</code> and contain the index-labels of the group-representatives as values.  These columns have the same names as their counterparts prefixed by the string <code>'group_rep_'</code>. </p> <p>If <code>strings_id</code> is also given, then the IDs from <code>strings_id</code> corresponding to the group-representatives are also returned in an additional column (with the same name as <code>strings_id</code> prefixed as described above).  If <code>strings_id</code> has no name, it is assumed to have the name <code>'id'</code> before being prefixed.</p>"},{"location":"references/match_most_similar/","title":"match_most_similar","text":""},{"location":"references/match_most_similar/#arguments","title":"Arguments","text":"<pre><code>match_most_similar(master: pd.Series,\n                   duplicates: Optional[pd.Series],\n                   master_id: Optional[pd.Series],\n                   duplicates_id: Optional[pd.Series],\n                   **kwargs) -&gt; Union[pd.DataFrame, pd.Series]\n</code></pre>"},{"location":"references/match_most_similar/#result","title":"Result","text":"<p>If <code>ignore_index=True</code>, returns a <code>Series</code> of strings, where for each string in <code>duplicates</code> the most similar string in <code>master</code> is returned.  If there are no similar strings in <code>master</code> for a given string in <code>duplicates</code> (because there is no potential match where the cosine similarity is above the threshold [default: 0.8]) then the original string in <code>duplicates</code> is returned.  The output <code>Series</code> thus has the same length and index as <code>duplicates</code>.  </p> <p>For example, if an input <code>Series</code> with the values <code>\\['foooo', 'bar', 'baz'\\]</code> is passed as the argument <code>master</code>, and <code>\\['foooob', 'bar', 'new'\\]</code> as the values of the argument <code>duplicates</code>, the function will return a <code>Series</code> with values: <code>\\['foooo', 'bar', 'new'\\]</code>.</p> <p>The name of the output <code>Series</code> is the same as that of <code>master</code> prefixed with the string <code>'most_similar_'</code>.  If <code>master</code> has no name, it is assumed to have the name <code>'master'</code> before being prefixed.</p> <p>If <code>ignore_index=False</code> (the default), <code>match_most_similar</code> returns a <code>DataFrame</code> containing the same <code>Series</code> described above as one of its columns.  So it inherits the same index and length as <code>duplicates</code>.  The rest of its columns correspond to the index (or index-levels) of <code>master</code> and thus contain the index-labels of the most similar strings being output as values.  If there are no similar strings in <code>master</code> for a given string in <code>duplicates</code> then the value(s) assigned to this index-column(s) for that string is <code>NaN</code> by default.  However, if the keyword argument <code>replace_na=True</code>, then these <code>NaN</code> values are replaced with the index-label(s) of that string in <code>duplicates</code>.  Note that such replacements can only occur if the indexes of <code>master</code> and <code>duplicates</code> have the same number of levels.  (See tutorials/ignore_index_and_replace_na.md for a demonstration.)</p> <p>Each column-name of the output <code>DataFrame</code> has the same name as its corresponding column, index, or index-level of <code>master</code> prefixed with the string <code>'most_similar_'</code>.</p> <p>If both parameters <code>master_id</code> and <code>duplicates_id</code> are also given, then a <code>DataFrame</code> is always returned with the same column(s) as described above, but with an additional column containing those IDs from these input <code>Series</code> corresponding to the output strings.  This column's name is the same as that of <code>master_id</code> prefixed in the same way as described above.  If <code>master_id</code> has no name, it is assumed to have the name <code>'master_id'</code> before being prefixed.</p>"},{"location":"references/match_strings/","title":"match_strings","text":""},{"location":"references/match_strings/#arguments","title":"Arguments","text":"<pre><code>match_strings(master: pd.Series,\n              duplicates: Optional[pd.Series],\n              master_id: Optional[pd.Series],\n              duplicates_id: Optional[pd.Series],\n              **kwargs) -&gt; pd.DataFrame\n</code></pre>"},{"location":"references/match_strings/#result","title":"Result","text":"<p>Returns a <code>DataFrame</code> containing similarity-scores of all matching pairs of highly similar strings from <code>master</code> (and <code>duplicates</code> if given).  Each matching pair in the output appears in its own row/record consisting of</p> <ol> <li>its \"left\" part: a string (with/without its index-label) from <code>master</code>, </li> <li>its similarity score, and  </li> <li>its \"right\" part: a string (with/without its index-label) from <code>duplicates</code> (or <code>master</code> if <code>duplicates</code> is not given), </li> </ol> <p>in that order.  Thus the column-names of the output are a collection of three groups:</p> <ol> <li>The name of <code>master</code> and the name(s) of its index (or index-levels) all prefixed by the - string <code>'left_'</code>,</li> <li><code>'similarity'</code> whose column has the similarity-scores as values, and </li> <li>The name of <code>duplicates</code> (or <code>master</code> if <code>duplicates</code> is not given) and the name(s) of its index (or index-levels) prefixed by the string <code>'right_'</code>.</li> </ol> <p>Indexes (or their levels) only appear when the keyword argument <code>ignore_index=False</code> (the default). (See tutorials/ignore_index_and_replace_na.md for a demonstration.)</p> <p>If either <code>master</code> or <code>duplicates</code> has no name, it assumes the name <code>'side'</code> which is then prefixed as described above.  Similarly, if any of the indexes (or index-levels) has no name it assumes its <code>pandas</code> default name (<code>'index'</code>, <code>'level_0'</code>, and so on) and is then prefixed as described above.</p> <p>In other words, if only parameter <code>master</code> is given, the function will return pairs of highly similar strings within <code>master</code>.  This can be seen as a self-join where both <code>'left_'</code> and <code>'right_'</code> prefixed columns come from <code>master</code>. If both parameters <code>master</code> and <code>duplicates</code> are given, it will return pairs of highly similar strings between <code>master</code> and <code>duplicates</code>. This can be seen as an inner-join where <code>'left_'</code> and <code>'right_'</code> prefixed columns come from <code>master</code> and <code>duplicates</code> respectively.     </p> <p>The function also supports optionally inputting IDs (<code>master_id</code> and <code>duplicates_id</code>) corresponding to the strings being matched.  In which case, the output includes two additional columns whose names are the names of these optional <code>Series</code> prefixed by <code>'left_'</code> and <code>'right_'</code> accordingly, and containing the IDs corresponding to the strings in the output.  If any of these <code>Series</code> has no name, then it assumes the name <code>'id'</code> and is then prefixed as described above.</p>"},{"location":"references/options_kwargs/","title":"Options / **kwargs","text":"<p>All keyword arguments not mentioned in the function definitions above are used to update the default settings. The following optional arguments can be used:</p>"},{"location":"references/options_kwargs/#tokenization-settings","title":"Tokenization settings","text":"<ul> <li><code>ngram_size</code>: The amount of characters in each n-gram. Default is <code>3</code>.</li> <li><code>regex</code>: The regex string used to clean-up the input string. Default is <code>r\"[,-./]|\\s\"</code>.</li> <li><code>ignore_case</code>: Determines whether or not letter case in strings should be ignored. Defaults to <code>True</code>.</li> <li><code>normalize_to_ascii</code>: Determines whether or not unicode to ascii normarlization is done. Default to <code>True</code>.</li> </ul>"},{"location":"references/options_kwargs/#match-and-output-settings","title":"Match and output settings","text":"<ul> <li><code>max_n_matches</code>: The maximum number of matching strings in <code>master</code> allowed per string in <code>duplicates</code>. Default is 20.</li> <li><code>min_similarity</code>: The minimum cosine similarity for two strings to be considered a match.  Defaults to <code>0.8</code></li> <li><code>include_zeroes</code>: When <code>min_similarity</code> \u2264 0, determines whether zero-similarity matches appear in the output.  Defaults to <code>True</code>.  (See tutorials/zero_similarity.md.) </li> <li><code>ignore_index</code>: Determines whether indexes are ignored or not.  If <code>False</code> (the default), index-columns will appear in the output, otherwise not.  (See tutorials/ignore_index_and_replace_na.md for a demonstration.)</li> <li><code>replace_na</code>: For function <code>match_most_similar</code>, determines whether <code>NaN</code> values in index-columns are replaced or not by index-labels from <code>duplicates</code>. Defaults to <code>False</code>.  (See tutorials/ignore_index_and_replace_na.md for a demonstration.)</li> </ul>"},{"location":"references/options_kwargs/#performance-settings","title":"Performance settings","text":"<ul> <li><code>number_of_processes</code>: The number of processes used by the cosine similarity calculation. Defaults to  <code>number of cores on a machine - 1.</code></li> <li><code>n_blocks</code>: This parameter is a tuple of two <code>int</code>s provided to help boost performance, if possible, of processing large DataFrames (see Subsection Performance), by splitting the DataFrames into <code>n_blocks[0]</code> blocks for the left operand (of the underlying matrix multiplication) and into <code>n_blocks[1]</code> blocks for the right operand before performing the string-comparisons block-wise.  Defaults to <code>None</code>, in which case automatic splitting occurs if an <code>OverflowError</code> would otherwise occur.</li> </ul>"},{"location":"references/options_kwargs/#other-settings","title":"Other settings","text":"<ul> <li><code>tfidf_matrix_dtype</code>: The datatype for the tf-idf values of the matrix components. Allowed values are <code>numpy.float32</code> and <code>numpy.float64</code>.  Default is <code>numpy.float64</code>.  (Note: <code>numpy.float32</code> often leads to faster processing and a smaller memory footprint albeit less numerical precision than <code>numpy.float64</code>.)</li> <li><code>group_rep</code>: For function <code>group_similar_strings</code>, determines how group-representatives are chosen.  Allowed values are <code>'centroid'</code> (the default) and <code>'first'</code>.  See tutorials/group_representatives.md for an explanation.</li> </ul>"},{"location":"references/sg_class/","title":"String Grouper Class","text":""},{"location":"references/sg_class/#concept","title":"Concept","text":"<p>All functions are built using a class <code>StringGrouper</code>. This class can be used through pre-defined functions, for example the four high level functions above, as well as using a more interactive approach where matches can be added or removed if needed by calling the <code>StringGrouper</code> class directly.</p> <p>The four functions mentioned above all create a <code>StringGrouper</code> object behind the scenes and call different functions on it. The <code>StringGrouper</code> class keeps track of all tuples of similar strings and creates the groups out of these. Since matches are often not perfect, a common workflow is to:</p>"},{"location":"references/sg_class/#example","title":"Example","text":"<ol> <li>Create matches</li> <li>Manually inspect the results</li> <li>Add and remove matches where necessary</li> <li>Create groups of similar strings</li> </ol> <p>The <code>StringGrouper</code> class allows for this without having to re-calculate the cosine similarity matrix. See below for an example. </p> <pre><code>company_names = './data/sec_edgar_company_info.csv'\ncompanies = pd.read_csv(company_names)\n</code></pre> <ol> <li>Create matches</li> </ol> <pre><code># Create a new StringGrouper\nstring_grouper = StringGrouper(companies['Company Name'], ignore_index=True)\n# Check if the ngram function does what we expect:\nstring_grouper.n_grams('McDonalds')\n</code></pre> <pre><code>['McD', 'cDo', 'Don', 'ona', 'nal', 'ald', 'lds']\n</code></pre> <pre><code>string_grouper.n_grams('\u00c0brac\u00e2DABR\u00c0')\n</code></pre> <pre><code>['abr', 'bra', 'rac', 'aca', 'cad', 'ada', 'dab', 'abr', 'bra']\n</code></pre> <pre><code># Now fit the StringGrouper - this will take a while since we are calculating cosine similarities on 600k strings\nstring_grouper = string_grouper.fit()\n</code></pre> <pre><code># Add the grouped strings\ncompanies['deduplicated_name'] = string_grouper.get_groups()\n</code></pre> <p>Suppose we know that PWC HOLDING CORP and PRICEWATERHOUSECOOPERS LLP are the same company. StringGrouper will not match these since they are not similar enough. </p> <pre><code>companies[companies.deduplicated_name.str.contains('PRICEWATERHOUSECOOPERS LLP')]\n</code></pre> Line Number Company Name Company CIK Key deduplicated_name 478441 478442 PRICEWATERHOUSECOOPERS LLP                              /TA 1064284 PRICEWATERHOUSECOOPERS LLP                              /TA 478442 478443 PRICEWATERHOUSECOOPERS LLP 1186612 PRICEWATERHOUSECOOPERS LLP                              /TA 478443 478444 PRICEWATERHOUSECOOPERS SECURITIES LLC 1018444 PRICEWATERHOUSECOOPERS LLP                              /TA <pre><code>companies[companies.deduplicated_name.str.contains('PWC')]\n</code></pre> Line Number Company Name Company CIK Key deduplicated_name 485535 485536 PWC CAPITAL INC. 1690640 PWC CAPITAL INC. 485536 485537 PWC HOLDING CORP 1456450 PWC HOLDING CORP 485537 485538 PWC INVESTORS, LLC 1480311 PWC INVESTORS, LLC 485538 485539 PWC REAL ESTATE VALUE FUND I LLC 1668928 PWC REAL ESTATE VALUE FUND I LLC 485539 485540 PWC SECURITIES CORP                                     /BD 1023989 PWC SECURITIES CORP                                     /BD 485540 485541 PWC SECURITIES CORPORATION 1023989 PWC SECURITIES CORPORATION 485541 485542 PWCC LTD 1172241 PWCC LTD 485542 485543 PWCG BROKERAGE, INC. 67301 PWCG BROKERAGE, INC. <p>We can add these with the add function:</p> <pre><code>string_grouper = string_grouper.add_match('PRICEWATERHOUSECOOPERS LLP', 'PWC HOLDING CORP')\ncompanies['deduplicated_name'] = string_grouper.get_groups()\n# Now lets check again:\n\ncompanies[companies.deduplicated_name.str.contains('PRICEWATERHOUSECOOPERS LLP')]\n</code></pre> Line Number Company Name Company CIK Key deduplicated_name 478441 478442 PRICEWATERHOUSECOOPERS LLP                              /TA 1064284 PRICEWATERHOUSECOOPERS LLP                              /TA 478442 478443 PRICEWATERHOUSECOOPERS LLP 1186612 PRICEWATERHOUSECOOPERS LLP                              /TA 478443 478444 PRICEWATERHOUSECOOPERS SECURITIES LLC 1018444 PRICEWATERHOUSECOOPERS LLP                              /TA 485536 485537 PWC HOLDING CORP 1456450 PRICEWATERHOUSECOOPERS LLP                              /TA <p>This can also be used to merge two groups:</p> <pre><code>string_grouper = string_grouper.add_match('PRICEWATERHOUSECOOPERS LLP', 'ZUCKER MICHAEL')\ncompanies['deduplicated_name'] = string_grouper.get_groups()\n\n# Now lets check again:\ncompanies[companies.deduplicated_name.str.contains('PRICEWATERHOUSECOOPERS LLP')]\n</code></pre> Line Number Company Name Company CIK Key deduplicated_name 478441 478442 PRICEWATERHOUSECOOPERS LLP                              /TA 1064284 PRICEWATERHOUSECOOPERS LLP                              /TA 478442 478443 PRICEWATERHOUSECOOPERS LLP 1186612 PRICEWATERHOUSECOOPERS LLP                              /TA 478443 478444 PRICEWATERHOUSECOOPERS SECURITIES LLC 1018444 PRICEWATERHOUSECOOPERS LLP                              /TA 485536 485537 PWC HOLDING CORP 1456450 PRICEWATERHOUSECOOPERS LLP                              /TA 662585 662586 ZUCKER MICHAEL 1629018 PRICEWATERHOUSECOOPERS LLP                              /TA 662604 662605 ZUCKERMAN MICHAEL 1303321 PRICEWATERHOUSECOOPERS LLP                              /TA 662605 662606 ZUCKERMAN MICHAEL 1496366 PRICEWATERHOUSECOOPERS LLP                              /TA <p>We can remove strings from groups in the same way:</p> <pre><code>string_grouper = string_grouper.remove_match('PRICEWATERHOUSECOOPERS LLP', 'ZUCKER MICHAEL')\ncompanies['deduplicated_name'] = string_grouper.get_groups()\n\n# Now lets check again:\ncompanies[companies.deduplicated_name.str.contains('PRICEWATERHOUSECOOPERS LLP')]\n</code></pre> Line Number Company Name Company CIK Key deduplicated_name 478441 478442 PRICEWATERHOUSECOOPERS LLP                              /TA 1064284 PRICEWATERHOUSECOOPERS LLP                              /TA 478442 478443 PRICEWATERHOUSECOOPERS LLP 1186612 PRICEWATERHOUSECOOPERS LLP                              /TA 478443 478444 PRICEWATERHOUSECOOPERS SECURITIES LLC 1018444 PRICEWATERHOUSECOOPERS LLP                              /TA 485536 485537 PWC HOLDING CORP 1456450 PRICEWATERHOUSECOOPERS LLP                              /TA"}]}